# [FE] 자바스크립트 변수, 연산자, 타입

자바스크립트의 표준을 ECMAScript라고 부르며, 이 ECMA 버전에 따라 브라우저별 자바스크립트 엔진 지원이 달라진다. 최신 브라우저에서는 ES6(ECMAScript 6) 까지 지원된다. ES6는 ES5와 호환이 가능하다. 이는 ES6를 지원하는 브라우저는 ES5도 지원함을 의미한다.

## 변수

변수는 데이터를 저장할 컨테이너 역할을 한다. 이 변수에는 숫자, 문자열, 배열, 객체 등 다양한 데이터를 저장할 수 있다.

### 변수 선언 방법 : var 키워드

자바스크립트에서는 **var 키워드**를 이용해서 변수를 선언할 수 있다.

```js
var a = 6;
var name = "Chan Jun";
```

- **var 키워드 변수는 선언과 동시에 초기화된다.** 변수가 초기화 된다는 것은 메모리에 **변수를 위한 공간이 할당되었다는 것**을 의미한다.
- '=' 기호를 통해서 변수에 값을 할당할 수 있다. 만약 변수를 선언만 하고 특별한 값을 할당하지 않는 경우 변수는 초기화 될 때 `undefined` 라는 값이 할당된다.

var 키워드를 사용하여 선언된 변수는 일반적인 프로그래밍 언어와는 다른 특징을 갖게된다.

#### 동일한 이름의 변수를 여러번 중복해서 선언 할 수 있다

다음과 같은 코드는 오류를 발생시키지 않는다.

```js
var a = 6;
var a = "test";
```

#### 변수가 선언되기 전에 참조할 수 있다

자바스크립트에는 **호이스팅(hoisting)** 이라는 특징이 있다.

- **호이스팅(hoisting)** : 자바스크립트 파서가 자바스크립트 파일을 분석할때, 변수 선언문이나 함수 선언문을 먼저 파악해서 처리하는 특징. 변수 및 함수 선언문이 코드 위쪽으로 끌어올려(Hoisting)져서 먼저 처리되는 것 같다고 해서 이름이 붙여졌다.

호이스팅이라는 기능 덕분에 아래 문장은 오류를 발생시키지 않는다.

```js
console.log(a); // undefined 출력됨
var a = "test";
```

호이스팅은 실제로 변수 선언문이나 함수 선언문을 코드 위쪽으로 끌어올리는 것은 아니지만 위 코드는 논리적으로 다음과 같은 코드처럼 해석되고 실행되었다고 볼 수 있다.

```js
var a;
console.log(a); // undefined 출력됨
a = "test";
```

- 일단 변수 a에 대한 선언문 `var a;` 가 코드 맨 위쪽으로 끌어올려졌다.
- 변수 선언시에 특별한 값을 할당하지 않았기 때문에 a의 값은 `undefined` 이다.

### 변수 선언 방법 : let, const 키워드

ES6 문법에서 변수를 선언하는 **let, const** 키워드가 추가되었다. 이 키워드들은 var 키워드를 이용해서 변수를 선언할때 생길 수 있는 문제점을 보완하기 위해서 추가되었다.

- 동일한 이름의 변수를 여러번 재선언할 수 없다.
- **var** 키워드와 같이 **let, const** 키워드로 선언한 변수들도 호이스팅 된다. 그러나 실제 변수 선언 문장이 등장하기 전에 **let, const** 키워드로 선언한 변수들을 참조하면 에러가 발행한다. 이런 **변수의 스코프 시작부터 변수 선언문까지를 일시적 사각지대(Temporal Dead Zone)** 라고 한다.
- let과 const 키워드의 차이점은 값을 여러번 재할당 할 수 있는지 여부이다. const 키워드로 선언된 변수에는 선언과 동시에 특정 값을 할당해주어야 한다. 또한 여러번 값을 재할당 할 수 없다.

### 타입

#### 자바스크립트 변수는 동적 타이핑 된다

자바스크립트 변수는 여러 타입의 데이터를 저장할 수 있다. 데이터의 타입은 `숫자`, `문자열`, `배열`, `객체` 등이 있다. 다른 프로그래밍 언어에서는 변수가 저장할 데이터의 타입에 따라서 변수의 타입도 지정해주어야 한다. 그러나 자바스크립트는 **변수에 데이터가 할당되는 시점에 타입이 결정되는 동적 타이핑**을 지원한다.

#### 데이터의 타입을 확인하는 방법

- 기본 primitive data : `typeof` 연산자를 이용해서 확인할 수 있다. 이 연산자는 데이터 타입을 문자열로 반환한다.
- 객체 data를 포함한 모든 데이터 : `toString.call()` 메소드를 이용해서 확인할 수 있다. `[object Number]` 형태의 문자열을 반환한다. `typeof` 연산자는 모든 객체들에 대해서 `object`라는 값만을 반환하기 때문에 객체들의 종류를 판단하는데는 사용할 수 없다.

## 연산자

자바스크립트의 연산자는 다른 프로그래밍 언어에서 지원하는 연사자들 대부분을 지원한다. 그러나 어떤 연산자들은 자바스크립트에서 특별한 동작을 취하게 된다.

### ==, ===

`==` 연산자는 좌우 피연산자의 값이 같은지를 비교할때 사용한다. 이때 주의할 점은 자바스크립트는 의미적으로 두 피연산자 값이 같다고 생각될 때 두 개 데이터의 타입이 다르더라도 `true`를 리턴한다.

```js
// true를 리턴
console.log(0 == '0');
console.log(0 == '');
console.log(0 == ' ');
console.log(0 == false);

// false를 리턴
console.log(0 == null);
console.log(0 == undefined);
```

만약 두 피연산자의 값 뿐만 아니라 타입까지 일치하는지를 알고 싶다면 ===를 사용하면 된다.

```js
// 모두 false를 리턴
console.log(0 === '0');
console.log(0 === '');
console.log(0 === ' ');
console.log(0 === false);
console.log(0 === null);
console.log(0 === undefined);
```

### ||, &&

일반적인 프로그래밍 언어와는 다르게 자바스크립트는 **||, &&** 연산자의 피연산자로 `boolean` 타입 이외의 데이터를 사용할 수 있다. 이때 각 연산자의 반환값은 다음과 같이 계산된다.

- **피연산자1 || 피연산자2** : 피연산자1이 true로 해석될 수 있으면 피연산자1을 반환, 아니라면 피연산자2를 반환
- **피연산자1 && 피연산자2** : 피연산자1이 true로 해석될 수 있으면 피연산자2를 반환, 아니라면 피연산자1를  반환
- **!피연산자** : 단일 피연산자를 true로 해석할 수 있으면 false, 아니면 true를 반환

이러한 특징을 이용해서 다음과 같이 문자열을 변수에 대입할 때, 디폴트 값을 설정할 수 있다.

```js
function printName(name) {
    var myName = name || "default value";
    console.log(myName);
}

printName();    // default value 출력
```
