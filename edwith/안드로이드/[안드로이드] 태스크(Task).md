# [안드로이드] 태스크 (Task)

안드로이드 앱은 **인텐트(Intent)** 를 통해서 다른 앱에 속한 액티비티도 실행시킬 수 있는 아주 강력한 기능을 가지고 있다. 예를 들어서 카카오톡 앱에서 유저들끼리 주고 받은 동영상을 재생할때, 카카오톡 앱 내부의 비디오 플레이어가 아닌 스마트폰 제조사의 비디오 플레이어 액티비티가 등장해서 동영상을 재생하게 된다. 이같은 기능은 앱 개발자가 구현해야하는 기능의 범위를 줄여주고, 다른 앱을 마치 자신들의 앱의 일부인것처럼 사용할 수 있다.

사용자의 입장에서는 앱을 사용할때 다른 앱에 속한 액티비티가 실행되더라도, 하나의 흐름에서 앱이 실행되고 있다고 느끼게된다. 안드로이드 시스템은 사용자가 자연스럽게 하나의 흐름 속에서 앱을 실행하고 있다고 느끼도록 여러 액티비티들 간의 구조를 **태스크(Task)** 라는 형태로 관리한다.

태스크는 간단히 이야기하면 액티비티들을 스택 형태로 저장해두는 것을 의미한다. 사용자가 어떤 앱을 런처에서 터치하여 실행시키면 해당 앱에 대한 태스크가 생성되며 첫번재 액티비티가 태스크의 스택에 쌓인다. 이 후 액티비티 내부에서 다른 액티비티를 생성하면 다시 스택의 TOP에 새로 생성된 액티비티가 쌓이며 TOP에 있는 액티비티가 화면에 보이게 된다.

사용자가 Back 버튼을 눌러서 액티비티를 종료하면 태스크 스택에서 해당 액티비티가 POP 되고, 그 아래 있던 액티비티가 TOP 이 되어 화면에 보여진다. 계속해서 Back 버튼을 눌러 태스크 스택 내부에 있던 모든 액티비티가 제거되면 태스크는 종료되고 제거된다.

![diagram_backstack](https://user-images.githubusercontent.com/31771548/100703160-523a9e00-33e6-11eb-9127-eeb7b5e7176a.png)
- *[Google Developers](https://developer.android.com/guide/components/activities/tasks-and-back-stack) / [CC BY](https://creativecommons.org/licenses/by/2.5/)*

한번에 여러개의 태스크가 실행될 수도 있다. 예를 들어 하나의 앱을 실행하고 있다가 홈 버튼을 눌러서 홈화면으로 돌아온뒤 다른 앱을 실행하면 각각의 앱에 대한 태스크들이 생성된다. 이전에 실행되던 태스크는 화면에서 더이상 보이지 않는다. 이런 상태를 태스크가 focus를 잃고 background 상태로 전환되었다고 한다. 다시 사용자가 홈 화면으로 이동한뒤 이전에 실행하고 있던 태스크에 대한 앱 런처 아이콘을 터치하면 이전 태스크가 화면에 보이기 시작하며 foreground 상태가 되며 태스크 스택의 탑에 있던 액티비티가 화면에 보인다. 이런 동작이 안드로이드에 멀티 태스킹을 수행하는 방식이다.

이런 기본 동작 방식은 되도록이면 앱 개발자가 특별히 신경을 쓰지 않아도 될 정도로 잘 정의되어 있고, 개발자 역시 되도록이면 이같은 동작을 변경하지 않아야 한다. 그러나 때때로 이러한 기본 동작 방식을 변경하고 싶은 경우가 있을 수 있다. 예를 들어 앱에서 똑같은 액티비티가 계속해서 여러번 생성되는 경우 사용자가 앱을 종료하기 위해서는 똑같은 액티비티를 생성한 횟수만큼 Back 버튼을 눌러야하며, 이는 마치 앱이 정상적으로 종료되지 않는 것 같은 느낌을 주게된다. 앱 개발자는 해당 액티비티가 단 한번만 생성되며, 나중에 똑같은 액티비티를 만들어야 할때 새로 생성하지 않고 이전에 있던 액티비티를 재활용하고 싶을 수 있다.

액티비티와 태스크의 기본 동작을 변경하기 위해서 액티비티 **인텐트 플래그(Intent Flag)** 와 메니패스트 파일의 액티비티 관련 태그에서 **launchMode** 등과 같은 속성들을 사용할 수 있다. 해당 내용을 명확하게 설명하기 위해서 그전에 몇가지 개념에 대해서 정리한다.

## adb shell 사용하기

adb(android debug bridge) 를 사용하면 현재 스마트폰에 실행되고 있는 태스크와 액티비티들에 대한 정보를 눈으로 확인할 수 있다. 이런 확실한 로그를 확인하는 것이 스마트폰 화면을 통해서 간접적으로 태스크를 확인하는 것보다 명확하기 때문에 좋다. 여기서 사용해볼 기능은 `adb shell activity activities > test.txt` 형태의 명령이다.

먼저 **`adb.exe`** 파일이 있는 경로로 이동하던지 아니면 명령 프롬프트의 어느 working directory에서나 사용할 수 있도록 **`adb.exe`** 파일의 경로를 path 환경 변수에 등록해둔다. 윈도우즈 같은 경우 이런 경로에서 찾을 수 있었다.

> C:\Users\user\AppData\Local\Android\Sdk\platform-tools

그 다음 애뮬레이터를 실행하거나 스마트폰 단말을 USB로 연결한다. 이때 개발자모드에서 USB 디버깅 기능을 활성화해야한다.

## 태스크 관련 용어

### 태스크 이름

각각의 태스크에는 이름이 부여되며 해당 태스크를 생성하게 만든 액티비티의 `android:taskAffinity` 속성값으로 설정된다. 보통 이 속성값은 액티비티가 속한 앱의 패키지 이름(문자열)이 된다. 아무리 태스크가 여러 앱의 액티비티의 조합으로 이루어질 수 있다고 해도, 태스크의 기반이 되는 앱이 있기 마련이다. 그런 앱의 이름을 이용해서 태스크에 이름을 부여하는 것 같다.

### 루트 액티비티, 탑 액티비티

태스크 스택의 맨 아래의 액티비티를 루트 액티비티라고 한다. 또 태스크 스택의 탑에 위치한 액티비티를 탑 액티비티라고 한다. foreground의 탑 액티비티만이 화면에 보여지게된다.

### 부모 액티비티, 자식 액티비티

특정 액티비티에서 인텐트를 이용하여 다른 액티비티를 생성하면, 생성하는 액티비티를 부모 액티비티, 생성되는 액티비리를 자식 액티비티라고 많이 부른다.

### 태스크 친밀도 (Task Affinity)

**Task Affinity** 는 새로 생성된 액티비티가 어느 태스크 스택 위에 쌓일지를 결정하는 속성이다. 기본적으로 액티비티는 본인을 생성한 액티비티가 존재하는 태스크 스택 위에 쌓이게 된다. 그러나 이후에 설명할 인텐트 플래그를 설정하면, 액티비티의 `taskAffinity` 속성에 명시된 이름과 동일한 이름을 같은 태스크 스택 위에 쌓이게 된다. `taskAffinity` 속성이 존재하지 않으면 디폴트로 앱의 패키지 이름이 `taskAffinity` 속성값이 된다.

## 인텐트 플래그 (Intent Flag)

인텐트 플래그라는 것을 인텐트에 설정하여 새로 생성된 액티비티가 어떤 형태로 태스크에 쌓일지를 결정할 수 있다. 인텐트 플래그는 비트 세팅방식으로 여러가지 설정을 중첩해서 사용할 수 있다. 다음과 같은 세팅을 사용할 수 있다.

- **`FLAG_ACTIVITY_NEW_TASK`** : 액티비티의 `taskAffinity` 값으로 설정된 이름에 해당하는 태스크에 새로 생성된 액티비티가 쌓이게 된다. 만약 그러한 태스크가 존재하지 않으면 새로 태스크를 생성하고, 생성된 액티비티를 해당 태스크의 루트 액티비티로 설정한다.
- **`FLAG_ACTIVITY_SINGLE_TOP`** : 액티비티 생성시, 생성되는 액티비티와 그 액티비티가 쌓이게 될 태스크의 탑 액티비티가 같은 경우 액티비티 객체를 새로 생성하지 않고 기존의 액티비티를 재사용한다. 이때 인텐트는 탑 액티비티의 `onNewIntent` 콜백 메소드를 통해서 전달된다.
- **`FLAG_ACTIVITY_CLEAR_TOP`** : 액티비티가 쌓이게 되는 태스크 내에 이미 해당 액티비티가 존재하면, 스택 상에서 원래 존재하던 액티비티와 그 위에 있던 모든 액티비티를 제거하고, 새로 액티비티를 생성한다.

이 3가지 인텐트 플래그는 서로 조합되서 사용될 수 있다.

- **`FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP`** : 액티비티는 태스크 친밀도가 같은 태스크 스택에 생성되고, 이미 해당 액티비티가 존재하면 액티비티 포함 그 위 액티비티들을 모두 제거한 다음 새로 액티비티를 생성하여 쌓는다.
- **`FLAG_ACTIVITY_SINGLE_TOP|FLAG_ACTIVITY_CLEAR_TOP`** : 태스크 내의 새로 생성하고자 하는 액티비티가 존재하는 경우 해당 액티비티의 위에 있는 액티비티들만 제거한 다음 원래 액티비티를 재사용한다. 이때 인텐트는 재사용되는 액티비티의 `onNewIntent` 콜백 메소드를 통해 전달된다.

## `<activity launchMode="">`

**`AndroidManifest.xml`** 파일의 **`<activity launchMode="">`** 를 사용하면 해당 속성이 설정된 액티비티가 생성되는 모든 경우에 액티비티가 태스크에 쌓이는 기본 동작을 설정할 수 있다.

- **`standard`** : 기본 모드. 액티비티를 생성한 태스크 스택에 쌓인다.
- **`singleTask`** : `FLAG_ACTIVITY_NEW_TASK` 와 동일한 형태. 액티비티의 `taskAffinity` 속성값으로 설정된 이름의 태스크에 액티비티가 쌓이고, 만약 그런 태스크가 없다면 새로 태스크를 생성한 뒤, 액티비티를 해당 태스크 스택의 루트로 설정하여 넣는다.
- **`singleInstance`** : `singleTask` 다만 새로 생성되는 액티비티가 반드시 태스크 스택 상의 루트가 되어야 하며, 해당 액티비티가 태스크의 유일한 액티비티여야 한다. 따라서 해당 액티비티를 위해 항상 새로운 태스크가 생성된다.

## 태스크간의 순서 및 백 스택(Back Stack)

액티비티들은 태스크 내의 스택 구조로 관리되어 사용 흐름이 결정된다. 이와 유사하게 태스크 간에도 일종의 순서 구조가 있는 것 같다. 예를 들어 홈화면에서 어떤 앱 a를 실행하고, 해당 앱에서 또다른 태스크를 생성하는 다른 앱 b의 액티비티를 생성하면 홈 화면 태스크 - a 태스크 - b 태스크 순서로 태스크가 생성되며 사용자가 back 키를 연속해서 누르는 경우 b화면, a화면, 홈 화면 순서대로 태스크가 화면에 표시된다. 이처럼 화면에 표시될 전체적인 액티비티가 저장되는 구조를 **백 스택 (Back stack)** 이라고 하는 것 같다.

![diagram_backstack_singletask_multiactivity (1)](https://user-images.githubusercontent.com/31771548/100703164-54046180-33e6-11eb-8bae-292b98cdf49f.png)
- *[Google Developers](https://developer.android.com/guide/components/activities/tasks-and-back-stack) / [CC BY](https://creativecommons.org/licenses/by/2.5/)*

만약 어떤 태스크 실행 중에 인텐트 플래그나 launchMode 등을 이용해서 새로운 액티비티를 생성하여 다른 Task에 넣게되는 경우, 해당 Task 내의 모든 액티비티가 위 그림처럼 백 스택에 쌓이게 된다.
